zj

# 性能优化都做了什么？都从哪些方面
- 1.减少资源的⼤⼩：（Webpack Bundle Analyzer插件分析和可视化 webpack 打包产物体积）
- - 收敛全局依赖
- - 引入依赖包minify版本(如terser、css-minimizer-webpack- plugin等)
- - 缩减包体积，按需引入

- 2.请求资源优化措施
- - 缩短请求链路:将资源部署在CDN上,缓存资源 （service worker、storage、 html cache）

- 3.将⼤的请求拆解为多⼩请求
- - 第三⽅包（node_modules下的包）单独打包
- - css代码从js⽂件中拆出成单独css⽂件
- - 延迟加载: ⽤dynamic import: () => import('./lazy-module')

- 4.优化【同步脚本】执⾏时间(火焰图)
- - 通过⽕焰图，找到long task，然后找其中self time⻓的任务，逐项分析解决

# 说一下什么是cdn？
CDN（是Content Delivery Network的缩写）即“内容分发网络”，它是一种旨在通过将内容传输到离用户更近的服务器来加快互联网内容分发的一种系统。
优点：CDN将网络内容分散到多个地理位置的服务器上，减少服务器的带宽负载并加快内容访问速度。也保证了大流量访问时网站的稳定运行。
额外优势：DDoS攻击防护

DDos(分布式拒绝服务攻击的缩写)，这是一种通过大量的、协同的网络请求来淹没服务器或网络的攻击方式，使得正常用户无法访问该服务器或网络上的资源。


# 说一下flex布局
是一种一维的布局模型，给flexbox的子元素之间提供了强大的空间分布和对齐能力。
常用语移动端适配，使用垂直和水平居中。

# vue和react的区别，哪个更推荐
都是很流行的js框架，用于构建页面和单页面应用，更推荐哪个与使用的具体需求和目标实现相关。
- Vue
vue的创始人是国内的尤雨溪，所以中文文档看起来会更容易理解，对于初学者很友好，能够更快上手，学习曲线相对平缓；
vue是一种声明式编程，灵活有便于理解；
vue的api更直观、易于理解，有一套相对完整的解决方案官网路由器和状态管理体系；

- React
社区相对更强大，活跃度更高，遇到问题寻找解决方案和第三方库会很容易；
react是一个库而不是一个框架。所以使用上可以更灵活可定制，可以和其他不同的第三方库一起使用，但是会使初学者不容易上手，学习曲线更陡峭；
react是国外Facebook的开源库，有许多大中型企业在使用，所以能够相信他会被持续维护，相对稳定。

- 两者区别
1. [模板与JSX]
vue是基于HTML的模版语法，使HTML/CSS/JS分离更加直观，熟悉这种模式的开发者会更容易上手；
react是JSX语法，是一种将HTML/JS混合在一起的语法，虽然不容易上手但是有更高的灵活性和组合性；
2. [数据绑定]
vue实现了双向数据绑定，允许你在模版中更改数据，这些更改会自动反应到Vue的实例中，使得数据的处理更加直观；
react是单向数据流，要求在父组件中集中的处理和显示传递数据，使得数据流更加清晰，更加易于调试；
3. [集成性和灵活性]
vue的生态环境相对完整，有一套完整的解决方案包括路由和状态管理，更加容易构建完整的前端应用；
react是更小、更灵活的库，允许你选择和集成其他的库来满足实现你的需求，但是需要花费一些精力和时间配置和研究第三方库的功能和使用；
4. [响应式系统]
vue在其核心内创建了一响应式系统，使用（Vue2.0）Object.defineProperty或(vue3.0之后)Proxy来追踪依赖和更新视图，有利于开发者可以更加集中精力在应用程序逻辑的编写，而不需要担心何时和如何更新他们的视图；
react依赖于setState和Hooks（React 16.8之后）来触发组件的重新渲染。

# vue3的响应式是用proxy实现的,那Proxy用过么 用来做什么了？
proxy是ES6引入的一种新的数据类型，它提供了一种机制来自定义基础操作行为。
也理解为Proxy是一个在对象和访问它的程序之间的中间层，可以用来定义和自定义对象的行为；
```
let handler = {
    get: function(target, prop, receiver) {
        console.log(`Get was called for prop: ${prop}`);
        return Reflect.get(...arguments);
    }
};

let target = { a: 1 };
let p = new Proxy(target, handler);
console.log(p.a); // 在这个例子中，当你试图访问属性 a 时，get trap 会被触发，并打印出一条消息

```

- Proxy常用来：
1. 数据绑定/观察者模式： 实现数据的响应式系统
2. 操作验证：用于验证在对象上执行的操作，例如，你可以使用 set trap 来验证属性设置操作，阻止设置无效的值或只读属性；
3. API封装：可以使用Proxy封装对外部API的访问，以实现错误处理，参数验证等。
4. 虚拟化：可以通过代理实现懒加载或模拟无限大的数组/对象
5. 日志记录和性能度量：可以使用Proxy来记录或度量对对象的访问，比如监控API的调用次数，或者度量调用的时间

# 什么是进程（process）什么是线程(thread)，二者什么关系
进程和线程是操作系统的抽象出来的概念。
js在浏览器中是单线程的。所以在任何一个时间点，都只有一个任务在执行，其他任务在事件队列中等待。
由于UI线程需要直观地反映用户的操作，所以采用单线程模型是最合理的。
单个CPU一次只能运行一个任务。

- 进程：一个进程是一个执行中的程序实例；
进程的内存空间是共享的，每个线程都可以使用这些共享内存。

- 线程资源共享需要关注的同步和互斥问题，防止数据不一致的问题，各种同步机制如下：
单线程的，当一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。
想防止多个线程同时读写某一块内存区域，可以加上“互斥锁”（Mutex）

多线程的，当多个线程使用某些共享内存时，其他线程等其中有结束的线程，进去一个线程，依次等外面所有排队的线程都进去。
为了保证多个线程不会互相冲突，可以使用“信号量”（Semaphore）

- 线程：一个线程是存在于进程内部的，线程是一小组指令，设计用于由CPU独立于父进程进行调度和执行；

# promise.all都是怎么实现的，为何可以单线程变成多线程？
首先Promise是在js中处理异常操作的一种机制，当Promise被创建的时候，就代表一个异步操作。
尽管JavaScript是单线程的，但js的异步操作不是在它的主线程中进行的，异步操作（如网络请求，定时器等）是由浏览器或者Node.js的底层中另外的线程中处理的。当这些异步操作完成时，他们的回调函数会被放到任务队列中，等待js主线程空闲时去执行。
# js的执行模型执行模型：EventLoop（事件循环）基本工作原理
这个模型的产生是因为，js是单线程的，但是它仍然要处理异步操作，比如网络请求，定时器等等。

同步任务：会在调用栈中按照他们出现的顺序立即执行；
异步任务：会在满足他们触发条件（如到达指定时间、收到网络响应等）后被放入任务队列中；
调用栈：一个存放任务的栈结构，js会从栈顶取任务并执行；
任务队列：是一个存放异步任务的队列，当异步任务的触发条件被满足时，对应的回调函数就会被放到任务队列；

EventLoop:调用栈中所有同步任务执行完后，js会查看任务队列中是否有任务。如果有就将任务队列中第一个任务移动到调用栈中，然后执行，这个过程会一直循环，因此叫事件循环。
# 什么是宏任务，什么是微任务，如何定义的宏任务微任务，谁先执行，
ES6中引入新型的任务队列，称为微任务队列。
微任务（Microtask）和宏任务（Macrotask）:微任务的优先级高于宏任务（普通的异步任务）。如果在执行完同步任务或者宏任务之后，微任务队列中有任务，JavaScript会处理所有的微任务，直到微任务队列为空，才会执行下一个宏任务。Promise 的回调就是一个典型的微任务。

1. 同步任务立即执行
2. 异步任务中看任务队列中的微任务队列
3. 再看任务队列中的宏任务队列

```
console.log('script start'); // 同步任务

setTimeout(function() {
    console.log('setTimeout'); // 宏任务
}, 0);

new Promise((resolve, reject) => {
    console.log(1111111); // 同步任务
}).then(function() {
    console.log('promise1'); // 微任务
}).then(function() {
    console.log('promise2'); // 微任务
});

console.log('script end'); // 同步任务

//  打印结果
script start
1111111
script end
setTimeout

```

补充：
当在 async 函数中使用 await 关键字时，它会暂停函数的执行，等待一个 Promise 对象的状态变为 resolved（已解决）后再继续执行后面的代码。这样可以避免使用回调函数或者 .then() 链式调用来处理异步操作的结果。
当使用 async/await 时，await 后面的 Promise 对象会被注册为一个微任务，它会在当前宏任务执行完毕后立即执行，而不需要等待下一个宏任务。这使得 await 在事件循环中的行为类似于微任务。

# Node 中的 Event loop

# commonJs和Es6区别
- 语法上： 
CommonJS 使用 require 来导入模块，使用 module.exports 或 exports 来导出模块。
ES6 则使用 import 和 export 关键词来导入和导出模块

- 加载方式上：
CommonJS 是同步加载模块，模块文件都存储在本地磁盘，读取速度非常快；
ES6 模块是异步加载的，模块文件可能需要从服务器获取，异步加载可以避免阻塞浏览器渲染。

- 运行时和编译时加载：
CommonJS 模块是运行时加载的，也就是说在运行代码时才确定模块的依赖关系和输入/输出的值。
ES6 模块则是编译时加载，依赖关系和输入/输出的值在代码编译阶段就已经确定

- 默认导出和命名导出：CommonJS 有一个module.exports可以用来导出模块的内容，而 ES6 允许模块有一个默认的导出（export default）和多个命名导出（export）。


- CommonJS 是“运行时加载”，require的模块就是对象，输入时必须查找对象属性。只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。
- ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。
实质是从模块中加载需要的方法，其他方法不加载。这种加载称为“编译时加载”或者“静态加载”，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。这也导致了没法引用 ES6 模块本身，因为它不是对象


# 说一下Node的洋葱模型 
中心：核心库（V8/事件循环库/内置库）
第一层：Node.js标准库（http、fs、path、crypto 等库）
第二层：第三方库（扩充 Node.js 的功能，如：express.js、koa.js 等 web 框架）
第三层：应用层（应用代码，调用 Node.js 的标准库或第三方库提供的功能）

# npm依赖和pnpm依赖区别

# 算法是大数相加 ‘12312312312’ + ‘23’

# 理解组合式函数compose，实现一个中间件
```
const compose = (...fns) => fns.reduce((a,b) => (...args) => (a(b(...args))))

```

# 实现 一个发布订阅模式（什么是发布订阅）


# 函数式编程
# 数组中some every each区别