遇到的项目的问题+你是怎么解决的？
IOS交互兼容问题：
1. sticky吸顶的问题 ->在写保险商城页面 本地和环境中吸顶效果不同 是因为我们的客户端老版本用的UIwebView 需要WKwebView才支持
2. 滚动穿透问题-> 原因：移动端当有 fixed 遮罩背景和弹出层时，touchmove事件的默认行为未阻止，在屏幕上滑动能够滑动背景下面的内容
解决：封装了高阶组件ScrollAllow
   touchmove + preventDefault
   接收props id
   禁止所有滚动 手动实现滚动--> 
   dom.scrollTop = (当前滚动的初始高度 - event.touches[0].clientY) + 滚动元素的初始高度
3. 在微信授权传递redirectUrl携带授权不断的encodeURIComponent 然后回来的时候再decodeURIComponent 但是期间有被解码过导致携带的tid参数丢失，经排查是由于 var rtnObj = URL.parse(rtnUrl, true)导致被解码了。


有哪些常用排序算法？
手写快排，快排时间复杂度是多少？
快排算法是不是稳定的？什么是稳定性？
给定一个字母组成的字符串，找出不含有重复字符的最长子串的长度。
9 个硬币中有一个劣币，用天平秤，最坏几次？
深度优先，广度优先
数字转中文
括号匹配，时间复杂度，空间复杂度
单向链表的归并排序
链表做加法(链表求和)
1g 大小文件，里面每行是最大 16k 的单词，限制内存 1m，统计单词频率最多的 100 个单词
手写 100 位带小数的大数字的减法
全排列。进阶：给数组长度 n，求第 k 行的排列
10.token放在本地如何保存？如何加密比较好？

聊对于 MVVM，MVC 和 MVP 的理解。(https://zhuanlan.zhihu.com/p/27302766)

介绍过往项目中 RN 的使用经验和遇到的问题。
### 讲如何将一张内存极大的图片可以像地图一样的加载出来（只说实现思路）
```
BaiduMapTileCutter瓦片切分工具，支持64位版本
将超大图片切割成瓦片地图，分级别展示，这样动态加载大图片时，只异步加载图片的部分区域，实现超大图片的高效加载显示
参考博客：https://blog.csdn.net/yiqiaoxihui/article/details/106674610

```
### 聊对于组件化的理解，对于市面上的组件化方案的理解，优劣分析等。
```
参考1：https://www.cnblogs.com/lmm1010/p/12993202.html
参考2：https://zhuanlan.zhihu.com/p/48191916

前提：
单工程架构则已经远远不能满足现有业务需求了，只让其他模块对中间层产生耦合关系，中间层不对其他模块发生耦合。 对于这个问题，可以采用组件化的架构，将每个模块作为一个组件。并且建立一个主项目，这个主项目负责集成所有组件。

优点：
业务划分更佳清晰，新人接手更佳容易，可以按组件分配开发任务。
项目可维护性更强，提高开发效率。
更好排查问题，某个组件出现问题，直接对组件进行处理。
开发测试过程中，可以只编译自己那部分代码，不需要编译整个项目代码。
方便集成，项目需要哪个模块直接通过CocoaPods集成即可。

市面上的组件化架构例子：
1. MGJRouter方案： 业内比较有代表性的就是蘑菇街的MGJRouter方案，实现方式大致是，在提供服务的组件中提前注册block，然后在调用方组件中通过URL调用block，下面是调用方式
2. Protocol方案：蘑菇街在原有组件化方案的基础上推出了Protocol方案。Protocol方案由两部分组成，进行组件间通信的ModuleManager类以及MGJComponentProtocol协议类。
3. CTMediator方案：该方案可以处理两种方式的调用，远程调用和本地调用。

缺点：
MGJRouter方案中URL硬编码，以及字典参数类型不明确等问题。
Protocol方案的代码量就比MGJRouter方案的要多，调用和注册代码量很大，调用起来并不是很方便。
以上两种方案都需要注册表，是一个NSMutableDictionary类型的字典，而字典的拥有者又是一个单例对象，这样会造成内存的常驻，会有一定内存消耗

```

算法：
1. 二叉树先序、中序、后序遍历
2. 两种降序的排序（快排、堆排）
3. 翻转二叉树
4. 深度广度优先遍历
5. 单链表的归并排序
6. 单链表求和


### 美团准备
垃圾回收机制有几种？https://zhuanlan.zhihu.com/p/259579683
- 引用计数和标记清除作为垃圾回收的基础方法

栈内的内存，操作系统会自动进行内存分配和内存释放，而堆中的内存，由JS引擎（如Chrome的V8）手动进行释放，